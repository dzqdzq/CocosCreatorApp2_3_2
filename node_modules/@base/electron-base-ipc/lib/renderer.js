"use strict";const{EventEmitter:EventEmitter}=require("events"),{ipcRenderer:ipcRenderer}=require("electron"),{MainSender:MainSender,EventSender:EventSender}=require("./sender"),{MessageEvent:MessageEvent,serializeError:serializeError,deserializeError:deserializeError}=require("./event"),pkg=require("../package.json"),ipcFlag=`${pkg.name}@${pkg.version}`;class BaseIpc extends EventEmitter{emit(e,...r){let n=this._events[e];return n||(n=[]),Array.isArray(n)||(n=[n]),new EventSender(n,{message:e,arguments:r})}send(e,...r){return new MainSender({message:e,arguments:r})}sendSync(e,...r){let n={message:e,arguments:r},s=ipcRenderer.sendSync(`${ipcFlag}:sendSync`,n);if(s.error)throw deserializeError(s.error);return s.value}}module.exports=new BaseIpc,ipcRenderer.on(`${ipcFlag}:broadcast`,(e,r)=>{let n=new MessageEvent("browser");n.sender=e.sender,EventEmitter.prototype.emit.call(module.exports,r.message,n,...r.arguments)}),ipcRenderer.on(`${ipcFlag}:send-reply`,(e,r,n,s)=>{let t=MainSender.query(r);t?(clearTimeout(t._timer),t._callback&&t._callback(deserializeError(n),...JSON.parse(s)),MainSender.remove(r)):console.warn("Sender does not exist")}),ipcRenderer.on(`${ipcFlag}:send`,(e,r)=>{let n=new MessageEvent("renderer");n.sender=e.sender,r.needCallback&&(n.reply=function(e,...n){!e||e instanceof Error||console.warn(`${r.message} - The first parameter of event.reply must be 'Error'`),ipcRenderer.send(`${ipcFlag}:send-reply`,r.cid,serializeError(e),JSON.stringify(n||[]))}),EventEmitter.prototype.emit.call(module.exports,r.message,n,...r.arguments)});